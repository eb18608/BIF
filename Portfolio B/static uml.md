Our static diagram was designed to be more broad than the dynamic diagram as we wanted to represent how our systems are interconnected throughout the whole app. Our app has fairly complex interactions that would be lost if we only showcased a smaller subsystem. We chose to use the visitor pattern as it provided a clear way to let our objects interact with each other. As there are multiple different types of **GameObject**, it seemed sensible to have them visit the **Physics Engine** and then allow that to manage the different collisions, etc. that would then take place.

It is also worth noting that **GameSketch** is represented centrally on our diagram. It is one of the most integral parts of our app; it uses and connects to the other key classes and handles the rendering functions and gameplay features as part of an overall *“game loop”*, which are vital to our game being playable. However, implementing our app in this way did raise challenges. We had issues making sure that the **GameObjects** interact as intended with the sketch, especially when they also needed to use data from the **IO** or the **Physics Engine** directly.  In order to solve this, we developed the **Collide Interactable** to allow any **GameObject** to visit in our design pattern.  This taught us the importance of designing class structure and hierarchies fully before we start implementing any functionality into our project.